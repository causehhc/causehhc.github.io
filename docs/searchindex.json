{"categories":[{"title":"Other","uri":"https://causehhc.github.io/categories/other/"},{"title":"中间件","uri":"https://causehhc.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"title":"嵌入式","uri":"https://causehhc.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"posts":[{"content":" 下载一些依赖项  sudo apt-get install \\\rpython-dev \\\rpython-setuptools \\\rpython-pip \\\rpython-smbus \\\rbuild-essential \\\rlibncursesw5-dev \\\rlibgdbm-dev \\\rlibc6-dev \\\rzlib1g-dev \\\rlibsqlite3-dev \\\rtk-dev \\\rlibssl-dev \\\ropenssl \\\rlibffi-dev\r 新建临时文件夹并进入，完成测试后可将本文件夹删除  mkdir py37_tmp \u0026amp;\u0026amp; cd py37_tmp\r 下载py37本体  wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz\r 解压  tar zxvf Python-3.7.3.tgz\rcd Python-3.7.3\r 编译  ./configure --with-ssl\rmake\rsudo make install\r 注意：–with-ssl必须加上，否则使用pip安装第三方包时，会引发ssl错误。导致无法使用。 6. 查找py37位置\nwhereis python3.7\r 7. 删除原py35版本的软链接\nsudo rm -rf /usr/bin/python3\rsudo rm -rf /usr/bin/pip3\r 创建软链接  # 添加python3的软链接\rsudo ln -s /usr/local/bin/python3.7 /usr/bin/python3.7\r# 添加 pip3 的软链接\rsudo ln -s /usr/local/bin/pip3.7 /usr/bin/pip3.7\r 测试  python3 -V\rpip3 -V\r 一些问题 在使用pip3安装包时报错：\nsubprocess.CalledProcessError: Command '('lsb_release', '-a')' returned non-zero exit status 1.\r 解决方案sudo rm /usr/bin/lsb_release\n","id":0,"section":"posts","summary":"下载一些依赖项 sudo apt-get install \\ python-dev \\ python-setuptools \\ python-pip \\ python-smbus \\ build-essential \\ libncursesw5-dev \\ libgdbm-dev \\ libc6-dev \\ zlib1g-dev \\ libsqlite3-dev \\ tk-dev \\ libssl-dev \\ openssl \\ libffi-dev 新建临时文件夹并进入，完成测试后可将本文件夹删除 mkdir py37_tmp \u0026amp;\u0026amp; cd py37_tmp 下载p","tags":["Ubuntu","Python"],"title":"ubuntu1604升级python版本到37","uri":"https://causehhc.github.io/2021/04/ubuntu1604-upgrade-python-version-to-37/","year":"2021"},{"content":"一、简述 首先说明我们为什么要实现内网穿透、是因为其他用户需要访问到我们在内网中部署的一些服务，而一般我们的入网设备是没有被分配到公网ip的，所以我们需要借助一台带有公网ip的服务器来对我们的消息进行转发。\n frp项目地址：https://github.com/fatedier/frp frp使用介绍：https://github.com/fatedier/frp/blob/master/README_zh.md  以下是【其他用户】访问【内网设备】的一条路径，其中我选择的方案是：公网服务器=阿里云，内网设备=ubuntu1604\n在公网服务器中运行frps、在内网设备中运行frpc\n二、服务端配置（阿里云服务器）  下载frp并解压，我使用的是0.36.2版本，可自行切换其他版本。  wget https://github.com/fatedier/frp/releases/download/v0.36.2/frp_0.36.2_linux_amd64.tar.gz\rtar -zxvf frp_0.36.2_linux_amd64.tar.gz\rcd frp_0.36.2_linux_amd64\r 编辑frps.ini .ini结尾一般为配置文件，其中frps.ini为程序运行时所需的配置文件。\n而frps_full.ini为所有配置的demo，大家可以按需配置。  # 通用配置\r[common]\r# frps服务在本机的监听地址及端口\rbind_addr = 0.0.0.0\rbind_port = 7000\r# frp 控制面板\rdashboard_port = 7500\rdashboard_user = admin\rdashboard_pwd = admin\r# 默认日志输出位置(这里输出到标准输出)\rlog_file = /dev/stdout\r# 日志级别，支持: debug, info, warn, error\rlog_level = info\rlog_max_days = 3\r 启动服务  ./frps -c frps.ini\r 以上命令在退出终端后就会停止，所以我们需要使frps在后台运行\n(1)运行  nohup ./frps -c frps.ini \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\r （2）停止 先找到这个进程再kill\nps -aux|grep frp| grep -v grep\rkill -9 [进程号]\r 三、客户端配置（内网设备） 客户端作为发起链接的主动方，只需要正确配置服务器地址，以及要映射客户端的哪些服务端口等即可\n 下载frp并解压  wget https://github.com/fatedier/frp/releases/download/v0.36.2/frp_0.36.2_linux_amd64.tar.gz\rtar -zxvf frp_0.36.2_linux_amd64.tar.gz\rcd frp_0.36.2_linux_amd64\r 编辑frpc.ini文件  # 通用配置\r[common]\r# 服务端地址及端口\rserver_addr = 你的公网ip\rserver_port = 7000\rlog_file = /dev/stdout\rlog_level = info\rlog_max_days = 3\r# 将本地 ssh 映射到服务器\r[ssh]\rtype = tcp\rlocal_ip = 127.0.0.1\rlocal_port = 22\rremote_port = 6000\r# 发布本地 web 服务\r[web]\rtype = tcp\r# 本地回环ip\rlocal_ip = 127.0.0.1\r# 5000一般为flask的默认开放端口\rlocal_port = 5000\r# 云服务器的80端口\rremote_port = 80\r 启动服务  ./frpc -c frpc.ini\r 四、测试启动情况 注意：由于云服务器的防火墙设置，在测试之前开放所需的端口，例如：7500（控制台端口）、以及你开放的各种【remote_port】。 服务端和客户端都启动后，访问http://你的公网ip:7500 以上实现的功能有：\n 通过访问【server_addr:remote_port】来实现间接访问【local_ip:local_port】，从而达到访问内网设备的服务。 访问【server_addr:7500】进入frp的控制台。  ","id":1,"section":"posts","summary":"一、简述 首先说明我们为什么要实现内网穿透、是因为其他用户需要访问到我们在内网中部署的一些服务，而一般我们的入网设备是没有被分配到公网ip的，","tags":["Ubuntu"],"title":"使用frp实现内网穿透","uri":"https://causehhc.github.io/2021/04/use-frp-to-achieve-intranet-penetration/","year":"2021"},{"content":"基于FPGA的16位单周期CPU设计 一、实验过程 1、ALU程序设计； 数据通路调用这个模块，根据得到的控制信号对输入数据进行处理，处理功能有：addu,add等。\n2、寄存器组设计； 由多个寄存器构成，用于存储各个数据结果。\n3、PC程序设计； 给出程序指令的地址，使得程序能够通过地址顺序执行。\n4、下地址部件设计； 地址逻辑转移器通过各个信号和指令中的操作码，判断下一条指令的地址，并能给出程序执行的下一条指令的地址。\n5、指令译码器设计 根据OP与FUNC（R型指令）共同输出最终执行指令。\n6、立即数扩展器设计 立即数扩展部件主要分为有符号扩展和无符号扩展，用于将8位立即数扩展为16位数据。扩展方式根据指令集中立即数是否有符号来判断，有符号扩展主要针对beq,bne,bgt,addi等指令，其余指令中的立即数采用无符号扩展。\n7、实验主电路的设计 二、实验结果与分析 1、实验结果和分析（采样表格形式） （1）数据存储器地址及内容 （2）程序清单以及功能说明 （3）运行结果对比和结果判断 2、错误或异常现象分析 现象：在ROM中指令无法正常跳转\n分析：问题主要出现在PC与ROM的连接方式错误，以及在观察现象时软件显示没有进行正确设置。\n资料下载\n","id":2,"section":"posts","summary":"基于FPGA的16位单周期CPU设计 一、实验过程 1、ALU程序设计； 数据通路调用这个模块，根据得到的控制信号对输入数据进行处理，处理功能有：","tags":["FPGA"],"title":"基于FPGA的16位单周期CPU设计","uri":"https://causehhc.github.io/2020/07/design-of-16-bit-single-cycle-cpu-based-on-fpga/","year":"2020"},{"content":"1、Keil软件安装步骤 1.1、安装详细步骤 1. 从官网得到Keil安装包（MDK-Arm）： https://www.keil.com/download/product/\n图 1-1 Keil官网下载界面 \n2. 在非系统盘（除c盘外）新建Keil_v5文件夹，用于存放keil软件。 图 1-2 选择路径 \n3. 双击MDK531.EXE开始安装，点击【next】。 图 1-3 安装界面 \n4. 勾选【agree】，点击【next】。 图 1-4 安装界面 \n5. 选择安装路径【Browser…】 放置在我们在一步建好的Keil_v5文件夹中，标蓝的部分需要手动输入（注意大写），路径不能带中文，点击【next】。\n图 1-5 选择两个路径 \n6. 填写用户信息，全部填【0】即可，点击【next】。 图 1-6 填写信息 \n7. 点击【finish】，安装完毕。 图 1-7 安装界面 \n8. 之后会弹出芯片包的安装程序，由于Keil公司服务器/网络问题，会一直卡在检查更新过程中（底边框可以查看进度）。所以需要取消勾选【Packs】-【Check for Updates on Lunch】，然后关闭。 图 1-8 包安装器 \n","id":3,"section":"posts","summary":"1、Keil软件安装步骤 1.1、安装详细步骤 1. 从官网得到Keil安装包（MDK-Arm）： https://www.keil.com/download/product/ 图 1-1 Keil官网下载界面 2. 在非系统盘（除c盘外）","tags":["STM32","Keil"],"title":"Keil(STM32)开发环境-(1)Keil软件安装步骤","uri":"https://causehhc.github.io/2020/07/keilstm32dev1/","year":"2020"},{"content":"2、Keil导入设备系列包 2.1、导入芯片包详细步骤 1. 下载芯片包 Keil5不像Keil4那样自带了很多厂商的MCU型号，Kei5需要自己安装芯片包，例如我们用的STM32F103RET6。可以从官网下载芯片包：http://www.keil.com/dd2/pack/\n图 2-1 Keil官网下载包  也可以直接使用Keil.STM32F1xx_DFP.2.3.0.pack，其中xx代表兼容不同版本，本芯片包可以支持我们当前所用的STM32F103系列，同时也支持其他F1系列，例如F100、F101等。\n2. 打开Keil软件，点击包安装器【Pack Installer】按钮。 图 2-2 包安装器在界面中的位置 \n3. 等待界面稳定后，点击【File】-【Import…】 图 2-3 选择导入\n4. 选择Keil.STM32F1xx_DFP.2.3.0.pack，点击【打开】。 图 2-4 选择包路径 \n5. 等待安装完毕后退出界面，至此芯片包导入完毕，可以开始下一步。 图 2-5 导入成功 \n","id":4,"section":"posts","summary":"2、Keil导入设备系列包 2.1、导入芯片包详细步骤 1. 下载芯片包 Keil5不像Keil4那样自带了很多厂商的MCU型号，Kei5需要自己安装","tags":["STM32","Keil"],"title":"Keil(STM32)开发环境-(2)Keil导入设备系列包","uri":"https://causehhc.github.io/2020/07/keilstm32dev2/","year":"2020"},{"content":"3、构建工程模板 首先查看【工程模板文件结构】\n 左侧为Keil自动生成的文件，其中绿色部分为文件夹，橙色部分为文件。 右侧为我们自己添加的文件，红色部分为主要编写的部分，以后的课程可能会对其他文件进行编辑。  图 3-1 工程模板文件结构\n3.1、右侧文件构建 可以根据网上的工程模板对右侧文件夹的理解与构建。 完成对右侧文件夹的构建后，接下来对左侧文件夹进行构建。\n3.2、左侧文件构建 1. 打开Keil软件，点击【Project】-【New uVision Project…】 图 3-2 新建工程 \n2. 找到之前构建的【右侧文件】位置进行操作 图 3-3 选择路径 \n3. 选择芯片型号，STM32F103RE 图 3-4 选择芯片型号 \n4. 这一步是软件中自带的配置【右侧文件】，我们不需要，点击Cancel 图 3-5 在线配置环境 \n5. 之后点击品字形按钮，让软件本身获取【右侧文件】的结构 图 3-6 按钮在界面中的位置 \n6. 通过操作【New】和【Delete】完成中间边框的编写，之后点击【Add Files…】 图 3-7 项目管理界面 \n7. 找到CMSIS-Src，选择全部文件，点击【Add】后，点击【Close】 图 3-8 选择添加文件 \n8. 重复步骤（6），创建，之后点击【Add Files…】 9. 找到目标源文件，选择全部文件，点击【Add】后，点击【Close】 10. 循环执行步骤（8）与步骤（9），最终添加效果如图 图 3-9 最终添加效果1 \n图 3-10最终添加效果2 \n图 3-11最终添加效果3 \n图 3-12最终添加效果4 \n11. 点击【OK】，可以在左侧边框看到工程模板文件已经添加完毕，接下来开始配置工程参数。 图 3-13最终添加效果5 \n","id":5,"section":"posts","summary":"3、构建工程模板 首先查看【工程模板文件结构】 左侧为Keil自动生成的文件，其中绿色部分为文件夹，橙色部分为文件。 右侧为我们自己添加的文件，红","tags":["STM32","Keil"],"title":"Keil(STM32)开发环境-(3)构建工程模板","uri":"https://causehhc.github.io/2020/07/keilstm32dev3/","year":"2020"},{"content":"4、配置工程参数 4.1、打开工程模板 首先打开工程模板，这是一个基础模板，之后可以在其基础上进行增量编程，由于可能需要被使用很多次，所以首先将模板做好备份。\n图 4-1 点击打开工程\n4.2、目标选项【Options for Target】的配置 点击该按钮，几乎所有工程参数的配置都将在这里进行。\n图 4-2 按钮在界面中的位置\n1. 设备【Device】 这里可选择芯片型号，我们选择STM32F103RE\n图 4-3 【Device】界面\n2. 目标【Target】 这里是关于工程目标的调试晶振频率、编译器、RAM和ROM的分配地址等，具体配置参考下图。\n图 4-4 【Target】界面\n3. 输出【Output】（不操作） 这里是调节输出内容，暂不对其操作。\n4. 列表【Listing】（不操作） 这里是关于编译时的汇编列表相关操作，暂不对其操作。\n5. 用户【User】（不操作） 这里是关于用户的使用设计，不常用，暂不对其操作。\n6. C/C++配置【C/C++】（最为重要） 此部分最为重要，是关于c/c++的相关配置，有预处理、语言代码生成、包含路径、多功能控件、编译器控制字符串。\n图 4-5 【C/C++】界面\n其中在本阶段包含路径要理解，有时明明include的一个头文件，但是程序就是报错，可能的原因就是因为程序找不到头文件所在路径，而头文件的搜索路径就是在这里面设置。\n图 4-6 添加包含路径\n这里不需要操作，因为工程所需的路径已经被包含，这里只讲解添加过程。值得一提的是，Inc文件夹一般放置头文件（.h文件，Inc就是include的缩写），Src文件夹一般放置源文件（.c文件）。\n图 4-7 将./Inc添加到路径中\n7. 汇编【Asm】（不操作） 这是关于汇编的设置，暂不对其操作。\n8. 链接【Linker】（不操作） 这是关于链接的设置，暂不对其操作。\n9. 调试【Debug】（比较重要） 这个选项比较重要，主要用于软件仿真、硬件在线调试、程序下载配置。\n有时候程序无法烧入开发板可能就是因为这里配置错误。\n*还有一种程序无法烧入开发板的原因可能是因为SWD端口被关闭，这时候需要将BOOT0和BOOT1拉高，写入空程序，然后再拉低烧入正常程序，具体操作原理这就是后话了，以后会展开讲解。\n这里我们用的是【ST-Link】下载器，所以选择此方式Debug。之后选择旁边的【Settings】，对其进行详细配置。\n图 4-8 【Debug】界面\n （a）在【Debug】栏中  是关于Debug方式和Debug速度的配置，具体配置参照下图。\n图 4-9 选择Debug方式\n （b）在【Flash Download】栏中  是关于下载的配置，stm32需要复位后程序才会执行，所以有时候开发板观察不到任何现象，这里可能就需要按一下复位按钮。但是勾选【Reset and Run】之后，即可实现自动复位，不需要每次下载程序后再按复位按钮。\n图 4-10 选择下载设置\n （c）在【Pack】栏中  如果上一步完成后还是不能自动复位，那么就点开【Pack】，取消勾选【Enable】。\n图 4-11 取消选中Enable\n10. 实用工具【Utilities】（不操作） 不常用，暂不对其操作。\n至此目标选项【Options for Target】配置完毕。\n","id":6,"section":"posts","summary":"4、配置工程参数 4.1、打开工程模板 首先打开工程模板，这是一个基础模板，之后可以在其基础上进行增量编程，由于可能需要被使用很多次，所以首先将","tags":["STM32","Keil"],"title":"Keil(STM32)开发环境-(4)配置工程参数","uri":"https://causehhc.github.io/2020/07/keilstm32dev4/","year":"2020"},{"content":"5、烧写测试程序 5.1、编译目标文件 在烧写程序之前，需要对目标工程进行编译链接，这里keil有三种编译模式。 分别是【Translate】、【Build】、【Rebuild】。\n图 5-1 按钮在界面中的位置\n1. 【Translate】 编译当前源文件，这个过程中会进行语法错误的检查，但是不生成可执行文件，一般在修改.c文件后，点击这个按钮，用来查看修改后的程序是否有语法错误。 因为只是编译当前的单个文件，所以编译速度快。\n2. 【Build】（最常用） 编译工程中的目标文件，目标文件通常指上次修改的文件以及其他依赖于这些修改过的文件的模块，同时重新链接生成可执行文件。如果工程之前没有编译链接过，它会直接调用【Rebuild】进行全部工程所以文件的编译链接。\n3. 【Rebuild】 重新编译工程中所有源文件，于上次编译的结果无关，不管工程的文件之前有没有编译过，都会对所有文件重新进行编译并生成可执行文件。 因此花费时间较长，平时使用较少。\n5.2、程序下载/烧写程序 1. ST-LINK V2下载器介绍 ST-Link是用于STM8和STM32微控制器的在线调试器和编程器，也就是下载器。ST-Link具有SWIM、JATG/SWD等通信接口。\n SWIM：Single Wire Interface Module，单线接口模块。 JATG：Joint Test Action Group，联合测试工作组，是一种国际标准测试协议。 SWD：Serial Wire Debugging，串行调试接口。 其中我们使用SWD方式进行程序下载与调试。  图 5-2 ST-Link下载器正视图 值得注意的是，在正面的接口标识层有一个白色实心框，这对应着后面的引脚，可以通过这种方法确定引脚位置和名称（如下图）。\n图 5-3 ST-Link下载器侧视图\n2. 开发板下载接口介绍 在下图中框选的位置就是利用ST-Link下载器下载程序的4个引脚。\n图 5-4 开发板正视图 其中各自的名称在旁边的电路板丝印已经被写明，为了更加直观，在下图中为大家标注出来。\n图 5-5 开发板上的SWD下载引脚\n3. 开发板与下载器连接方法 连接方法就是使用杜邦线，与双方引脚对应连接。\n 下载器的SWDIO引脚 \u0026ndash;连接\u0026ndash; 开发板的SWDIO引脚 下载器的GND引脚 \u0026ndash;连接\u0026ndash; 开发板的GND引脚 下载器的SWCLK引脚 \u0026ndash;连接\u0026ndash; 开发板的SWCLK引脚 下载器的3.3V引脚 \u0026ndash;连接\u0026ndash; 开发板的VCC引脚 值得注意的是，他们的引脚并不是一一对应的，所以需要打乱杜邦线的顺序进行连接，为了避免引起歧义，就不放上图片进行展示。 一定要正确连接，错误连接可能导致开发板或下载器烧毁！  4. 安装st-link驱动 （1）. 右键计算机，查看本系统是64还是32\n图 5-6 查看本机系统 （2）. 下载的st-link驱动安装包，双击安装\n图 5-7 ST-Link驱动安装程序 （3）. 如果安装成功，完成电脑-下载器-开发板连接后，下载器上的红色指示灯会常亮。如果安装失败，下载器上的红色指示灯会闪烁，请尝试重新安装。\n5. 在Keil软件中点击下载 连接完毕后，即可点击下载按钮进行下载。\n图 5-8 按钮在界面中的位置 出现此提示说明下载成功。\n图 5-9 程序下载成功\n","id":7,"section":"posts","summary":"5、烧写测试程序 5.1、编译目标文件 在烧写程序之前，需要对目标工程进行编译链接，这里keil有三种编译模式。 分别是【Translate】、【","tags":["STM32","Keil"],"title":"Keil(STM32)开发环境-(5)烧写测试程序","uri":"https://causehhc.github.io/2020/07/keilstm32dev5/","year":"2020"},{"content":"6、程序编写与基本调试 6.1、新建文件 通过我们之前对构建工程模板的学习，我们应该了解在创建文件时，一般需要将.c文件与.h文件一起添加。同时由用户自己创建的.c文件一般放置在./USER/Src文件夹中，由用户自己创建的.h文件一般放置在./USER/Inc文件夹中，这样整个工程才可以正常运行。 当然，这么做只是为了降低项目维护成本，但是这个习惯尤其重要。尤其是当你参与团队项目开发时，统一的开发习惯会大大增加团队的效率。 具体操作为：\n1. 点击【新建文件】 图 6-1 按钮在界面中的位置\n2. 新建完成后点击【保存】或按【Ctrl+S】进行保存 图 6-2 新建文件后的效果\n3. 打开./USER/Src，输入文件名，【加.c后缀】，之后点击【保存】 图 6-3 源文件保存操作\n4. 重复（1）（2）操作，之后打开./USER/Inc，输入与（3）同名（后缀不同）文件名，这次【加.h后缀】，之后点击【保存】 图 6-4 头文件保存操作\n5. 双击【USER】 图 6-5 按钮在界面中的位置\n6. 找到./Src位置，选择【test.c】，点击【add】，注意不需要将.h文件也add进来。 图 6-6 将源文件添加到组\n7. 现在可以观察到已经添加成功了。 图 6-7 最终添加效果`\n6.2、基本编写 在本阶段完成文件间的关联即可。\n1. .c文件的编写  导入自己的.h文件 函数实现（这里暂不要求）  图 6-8 源文件基本编写\n2. .h文件的编写  预编译语句，防止重复编译 导入标准库 ”stm32f10x.h” 宏定义（这里暂不要求） 函数声明（这里暂不要求）  图 6-9 头文件基本编写\n3. main文件的增量编写  导入刚刚编写的 “test.h” 使用“test.h”自己编写的库函数（这里暂不要求）  图 6-10 mian增量编写\n4. 编译 点击编译，下面会显示0 Error(s), 0 Warning(s)，编译通过\n图 6-11 编译通过\n6.3、在线调试 在线调试分为软件在线调试与硬件在线调试。由于现在硬件成本较低，一般我们都使用硬件在线调试，也就是软件直接下载到芯片，软件与硬件同步运行，我们可以查看运行状态。\n1. Keil支持硬件调试，为了说明功能，我们可以编写一段简单的程序。 点击侧边栏对这一行加断点，然后点击【Start/Stop Debug Session】\n图 6-12 按钮在界面中的位置\n2. 点击之后得到如下界面，如果左下角的【Command】栏中显示报错，或者与调试时的预期现象不符合，尝试退出后重新编译，再次进入。 图 6-13 界面整体介绍\n3. 由于篇幅有限，所以只介绍一些基本按钮的使用。  复位【Reset】：使程序复位到初始状态。 运行【Run】：让程序全速运行，直到遇到断点，程序将暂停。 停止【Stop】：停止运行。 单步调试【Step】：每点一次按钮，程序运行一步，遇到函数会进入。 逐行调试【Step Over】：每点一次按钮，程序运行一行，意味着遇到函数不进入。 跳出调试【Step Out】：每点一次按钮，程序跳出这个函数，直到回到main函数。  ","id":8,"section":"posts","summary":"6、程序编写与基本调试 6.1、新建文件 通过我们之前对构建工程模板的学习，我们应该了解在创建文件时，一般需要将.c文件与.h文件一起添加。同时","tags":["STM32","Keil"],"title":"Keil(STM32)开发环境-(6)程序编写与基本调试","uri":"https://causehhc.github.io/2020/07/keilstm32dev6/","year":"2020"},{"content":"〇、软件清单  STM32CubeMX Clion en.stsw-link009.zip —— ST-Link V2的驱动，Clion需要更新一下这个驱动 gcc-arm-none-eabi-5_4-2016q3-20160926-win32.exe —— win下的arm架构交叉编译环境 java1.8.0_261-jdk java1.8.0_261-jre LLVM-9.0.0-win64.exe —— c编译器，我VScode搭配的是这个+下面的MinGW MinGW —— c编译器，知乎那个教程好像用的是这个 openocd-esp32-win32-0.10.0-esp32-20200526.zip —— 下载程序用的 st_nucleo_f103rb_stlink_v2.cfg —— 自己写的一个OpenOCD的配置文件，放在XXX\\openocd\u0026ndash; esp32\\share\\openocd\\scripts\\board下，创建工程时需要选用这个  一、CubeMX 1、简介  cubemx是ST官方出的，一款使用HAL库，自动生成stm32初始化代码的软件。与其配套的IDE叫STM32CubeIDE，我没用过，你们可以试试。 HAL库：Hardware abstract layer，硬件抽象层，ST官方出的。首先要和标准库做对比，野火那套用的库函数就是标准库，它的特点是非常细节，具体到硬件实施，接近寄存器操作。而HAL库封装程度要高一点，各种函数或者变量的命名格式也很容易看懂，总之就是用的更顺手一点。 自动生成：字面意思，FULL AUTO。 初始化代码：意思就是只帮你初始化了，启动还是需要自己启动的。野火那套是初始化和启动写一起了，假如有多个设备联合工作，初始化好的就自己先跑起来了（例如定时器中断），相当异端。  2、使用流程 2.1、一般使用流程  芯片选型 配置RCC：选HSE-Crystal/Ceramic Resonator，配置时钟树 配置SYS：选Debug-Serial Wire 其他   注：只有当1-3步完成之后才能配置别的，否则可能会遇到奇怪的bug，例如没选debug方式的话下次程序就下不进去。  2.2、新手上路流程  一般软件下好打开之后就会让你导包，点这个  2. 选STM32F1系列，安装\n3. 开始上路，新建工程\n4. 直接输型号\n5. 打开界面后我也不做翻译了，上面这些选项卡懂得都懂，不知道可以查一下\n6. 配置系统核心（System Core），字面意思，都核心了肯定是重要的东西，在这里需要配置两个东西，一个是RCC，一个是SYS，其余默认。这俩一个是时钟树，一个是Debug方式，也就是下载方式，我们用的是SWD。\n7. 然后打开Clock Configuration，这里是真·时钟树，一般直接在这里输入72然后回车就完事了，软件会自动给你找合适的方案。\n8. 然后配置其他东西，这里就直接参考（可以暂时不弄）： 定时器中断：https://blog.csdn.net/toopoo/article/details/79748683 定时器PWM：https://blog.csdn.net/toopoo/article/details/79749851 定时器输入捕获：https://blog.csdn.net/as480133937/article/details/99407485 9. 然后保存，起个名字ctrl+S\n10. 然后选工具链和版本\n11. 选这俩\n12. 然后再保存一边直接点生成就好\n13. 然后可以看一下它生成的代码，值得注意的一点就是，你自己编写的代码必须放在这种格式里面【USER CODE BEGIN/END】，写在其他地方的话下次【生成】会被直接删掉。\n14. 剩下的自己看注释就好了。\n二、Clion+CubeMX联动 clion是啥就不用多说了，目前为数不多支持正经c语言的现代化大厂IDE。\npycharm、idea、goland都是jetbrains一家公司的，它们有统一的界面，非常友好。\n2.1、预习  用clion编stm32程序，首先看这篇：https://zhuanlan.zhihu.com/p/63672432 以上工作配置好后（意思是可以编译通过），开始配置流程，如果不安这个步骤来的话可能联动不起来。 只有当以上工作完成后才可以继续下一步。  2.2、一般使用流程  首先打开clion，创建一个stm32cubemx的工程。要明白工作区和工程文件夹的概念。例如下图中，建立在桌面的工作区【workspace】，在工作区中建立工程文件夹【project】，之后工程文件内容就存放在文件夹【project】里。如果是单级目录的话，cubemx或clion识别不到工具链。  2. 打开.ioc文件。\n在【芯片选型】之后，【设置时钟树】，【设置debug方式】之后。  4. 按照下图仔细配置，包括文件名和文件路径，文件名要和原来的一样，以便成功覆盖原文件。\n5. 只有出现这个提示后，文件才会被成功覆盖\n6. 切换回clion，会自动刷新，选择【这个】，【这个】是我自己写的，等你们做到这步之后我发你们。点开mian\n7. 然后就可以编代码了，小锤子是编译、箭头就编译后下载。\n8. 如果在cubemx对引脚重新命名之后，他这里代码也会自动补全。\n9. 然后就下载完成了\n10. 点亮LED小灯\n三、Issues  在使用cubemx前，确保java版本为1.8及以上、并且正确的配置环境变量，即java、javac均可在cmd中运行。 在使用clion时，需要正确的部署本机编译器和交叉编译器。本机编译器采用LLVM+MinGW联合使用，交叉编译器请安装gcc-arm-none-eabi。 在clion中，如果遇到找不到某种编译器，请检查是否正确安装本机编译器与交叉编译器。 下载程序时提示XXXLevel-Low，请更新ST-LINK V2驱动。 如果使用在线调试功能，请在ToolChain中Debug下选择：XXX\\GNU Tools ARM Embedded\\5.4 2016q3\\bin\\arm-none-eabi-gdb.exe。  ","id":9,"section":"posts","summary":"〇、软件清单 STM32CubeMX Clion en.stsw-link009.zip —— ST-Link V2的驱动，Clion需要更新一下这个驱动 gcc-arm-none-eabi-5_4-2016q3-20160926-win32.exe —— win下的arm架构交叉编译环境 java1.8.0_261-jdk java1.8.0_261-jre LLVM-9.0.0-win64.exe —— c编译器，我VScode搭","tags":["STM32","Clion","JetBrains"],"title":"Clion+STM32CubeMX使用指南","uri":"https://causehhc.github.io/2020/06/clion-stm32cubemx-user-guide/","year":"2020"},{"content":"一、简介 课设题目，这里简单总结一下思路。\n二、功能分析  任意穿行 （寻找终点）\n实现对步进电机的控制，包括正转反转及调速；对电机动作组进行封装，实现各种标准动作（前进一格，左转，右转，掉头，修正）。 记录信息 （遍历迷宫）\n通过建立8*8迷宫数组，在低四位以绝对方向记录墙的信息，高四位记录来的方向。以便后期分析和回溯。 最短路径 （BFS算法）\n利用广度优先算法计算等高表，从终点反向查找最短路径。  三、硬件驱动程序 1、数码管驱动 //数码管驱动程序\rsbit tube1 = P4^3;\rsbit tube2 = P4^2;\ruchar table[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90, 0x88,0x83,0xc6,0xa1,0x86,0x8e,0x00};\rvoid view1(uchar num){\rtube1=1;tube2=0;P0=table[num];\r}\rvoid view2(uchar num){\rtube1=0;tube2=1;P0=table[num];\r}\r 2、红外传感器组驱动 //红外传感器组驱动程序\rsbit A0 = P4^0;\rsbit A1 = P2^0;\rsbit A2 = P2^7;\rsbit irR1 = P2^1;\rsbit irR2 = P2^2;\rsbit irR3 = P2^3;\rsbit irR4 = P2^4;\rsbit irR5 = P2^5;\rbit irC=0, irL=0, irR=0, irLU=0, irRU=0;\rvoid init_tim2(uint us){ // 初始化TIM2\rEA = 1;\rET2 = 1;\rTH2 = RCAP2H = (65536-us)/256;\rTL2 = RCAP2L = (65536-us)%256;\rTR2 = 1;\r}\rvoid ir_on(uchar num){ // 开启第num-1号红外发射级\rA0 = (num)\u0026amp;0x01;\rA1 = (num)\u0026amp;0x02;\rA2 = (num)\u0026amp;0x04;\r}\ruchar get_ir(uchar num){\rif(num==1) return irL;\relse if(num==2) return irLU;\relse if(num==3) return irC;\relse if(num==4) return irRU;\relse if(num==5) return irR;\relse return 0;\r}\rvoid ir_test(){ // 测试某个方向的红外\rwhile(1){\rif(irL||irR||irC){\rbeep = 0;\r}else{\rbeep = 1;\r}\r}\r}\rvoid tim2() interrupt 5{ // TIM2中断服务函数\rstatic bit ir = 0;\rstatic unsigned char n=1;\rTF2 = 0;\rif(!ir)\t{\rir_on(n-1);\r}else{\rif(n==1){\rif(irR1)\tirC=0;\relse\tirC=1;\r}else if(n==2){\rif(irR2)\tirLU=0;\relse\tirLU=1;\r}else if(n==3){\rif(irR3)\tirL=0;\relse\tirL=1;\r}else if(n==4){\rif(irR4)\tirR=0;\relse\tirR=1;\r}else if(n==5){\rif(irR5)\tirRU=0;\relse\tirRU=1;\r}\r}\rif(ir)\tn++;\rif(n\u0026gt;5)\tn=1;\rir=~ir;\r}\r 3、步进电机驱动 //步进电机驱动程序\rvoid write_pin(uchar temp){\rP1 = temp;\r}\rvoid delay(uint z){ // 延时函数\ruchar i, j;\rwhile(--z){\r_nop_();\ri=2;\rj=199;\rdo{\rwhile(--j);\r}while(--i);\r}\r}\ruchar forward[]={0x11,0x33,0x22,0x66,0x44,0xcc,0x88,0x99};\ruchar reverse[]={0x11,0x99,0x88,0xcc,0x44,0x66,0x22,0x33};\ruchar for_rev[]={0x11,0x93,0x82,0xc6,0x44,0x6c,0x28,0x39};\rstatic uint step = 0;\ruchar fix_path(uchar i){ // 路线修正\rstep = 0;\rwhile((get_ir(2)||get_ir(4)) \u0026amp;\u0026amp; !get_ir(3)){\rif(get_ir(2))\twrite_pin(forward[i++] | 0xf0);\relse if(get_ir(4))\twrite_pin(reverse[i++] | 0x0f);\rif(i==8)\ti=0;\rstep++;\rdelay(3);\r}\rreturn i;\r}\rvoid go_rel(uchar relD){ // 向某个相对方向前进一格\ruchar num;\ruchar i, j;\rif(relD == 0) num = 104;\rif(relD == 1||relD == 3) num = 48;\rif(relD == 2) num = 100;\rfor(j=0;j\u0026lt;num;j++){\rfor(i=0;i\u0026lt;8;i++){\rif(relD == 1||relD == 2)\twrite_pin(forward[i]);\rif(relD == 3)\twrite_pin(reverse[i]);\rif(relD == 0){\rwrite_pin(for_rev[i]);\ri = fix_path(i);\r}\rif(relD==0)\tnum -= step/16;\rdelay(3);\r}\r}\r}\r 四、算法分析 1、遍历迷宫 遍历迷宫（回溯法）的一般流程如下： 1.1、定义绝对方向和相对方向 //算法部分\r/** 绝对方向（以迷宫左上为参照）： 相对方向：\r* 0 0:直行\r* 3 1 1:右转\r* 2 2:掉头\r* 3:左转\r**/\r/** 工具函数集（0）：一些必要的初始化及通用函数\r* 初始化数组\r*\t高四位记录来的方\r*\t低四位依据绝对方向记录记录四周信息（默认来的方向无墙）\r**/\rvoid init_map(uchar map[SIZE][SIZE]){ // 初始化数组\ruchar i, j;\rfor(i=0;i\u0026lt;SIZE;i++){\rfor(j=0;j\u0026lt;SIZE;j++){\rmap[i][j] = 0xff;\r}\r}\r}\ruchar abs_to_rel(uchar absD, uchar absD_t){ // 绝对方向-\u0026gt;相对方向\r//absD：当前绝对方向\r//absD_t：期望转换到哪个绝对方向\ruchar relD = 0;\rrelD = (absD_t - absD) % 4;\rif(relD \u0026gt; 127)\trelD += 4;\r//返回相对方向\rreturn relD;\r}\r 1.2、记录当前坐标的迷宫信息 当前坐标为初始值时（说明没走过）记录信息，高四位记录来的方向，低四位依据绝对方向记录四周信息。由于在整个行进过程中（遍历阶段）迷宫数组的值只会被写入一次，这保证了在高四位中始终记录的是最开始时小车进入的方向。依此特点，小车可以在回溯或冲刺时有效安全地使用这些信息。\n/** 关键函数集（1）：记录信息\r* 当前坐标为初始值时，记录信息：\r*\t高四位记录来的方向\r*\t低四位依据绝对方向记录记录四周信息（默认来的方向无墙）\r**/\ruchar read_ir(uchar relD){ // 读取相对方向的红外值\rif(relD == 0) return get_ir(3); // 前红外\rif(relD == 1) return get_ir(5); // 右红外\rif(relD == 3) return get_ir(1); // 左红外\rreturn 0;\r}\rvoid collect_info(uchar maze[SIZE][SIZE], xyTypeDef now, uchar absD){ // 记录信息\rif(maze[now.y][now.x] == 0xff){ // 如果当前坐标未被写入，则写入（整个过程中低四位只写入一次）\ruchar val_wall = 0xf0;\ruchar k = 0;\ruchar i;\rfor(i=0; i\u0026lt;4; i++){ // 循环判断4个绝对方向\rk = read_ir(abs_to_rel(absD, i));\rval_wall |= (k\u0026lt;\u0026lt;i);\r}\rmaze[now.y][now.x] \u0026amp;= val_wall; // 将墙的信息写入低四位\rmaze[now.y][now.x] \u0026amp;= ((absD\u0026lt;\u0026lt;4)|0x0f); // 将来的方向写入高四位\r}\r}\r 1.3、选择一个方向 更具记录的迷宫数组信息，选择一个合适的方向。扫描四轴，如果存在没走过的格子，直接返回这个方向。如果四周都走过，那么读取本坐标的高四位来的方向，选择回溯方向。\n/** 关键函数集（2）：选择方向\r* 根据记录的迷宫数组信息，选择合适的方向\r*\t扫描四周，如果存在没走过的格子，直接走之\r*\t如果四周都走过，那么读取高四位来的方向，进行回溯\r**/\ruchar is_path(uchar maze[SIZE][SIZE], xyTypeDef now, uchar absD){ // 判断此方向是否连通\rreturn !((maze[now.y][now.x]\u0026gt;\u0026gt;absD)\u0026amp;0x01);\r}\ruchar is_new(uchar maze[SIZE][SIZE], xyTypeDef now, uchar absD){ // 判断此方向是否为新格子\rif(absD==0) return (maze[now.y-1][now.x]\u0026gt;\u0026gt;4)==0x0f;\rif(absD==1) return (maze[now.y][now.x+1]\u0026gt;\u0026gt;4)==0x0f;\rif(absD==2) return (maze[now.y+1][now.x]\u0026gt;\u0026gt;4)==0x0f;\rif(absD==3) return (maze[now.y][now.x-1]\u0026gt;\u0026gt;4)==0x0f;\rreturn 0;\r}\ruchar search_dir(uchar maze[SIZE][SIZE], xyTypeDef now, uchar flag){ // 选择方向\ruchar i;\ruchar pre = maze[now.y][now.x] \u0026gt;\u0026gt; 4;\ruchar back;\rif(!flag){ // 冲刺标记位，如果不冲刺，则需要扫描四个方向是否可走\rfor(i=0; i\u0026lt;4; i++){\rif(is_path(maze, now, i) \u0026amp;\u0026amp; is_new(maze, now, i)){ // 判断该方向是否有墙和是否走过\rreturn i;\r}\r}\r}\r// 如果冲刺或者四个方向不可走，直接读取高四位进行冲刺引导或回溯\rif(pre\u0026lt;=1) back = pre+2;\rif(pre\u0026gt;=2) back = pre-2;\rreturn back;\r}\r 1.4、向这个方向前进 这方面没啥说的，动起来就对了。\n/** 关键函数集（3）：执行\r* 根据上一步得到的信息，执行\r**/\rvoid go_to_next(xyTypeDef *now, uchar *absD, uchar absD_t){\ruchar relD = abs_to_rel(*absD, absD_t);\r// 刷新当前坐标和当前绝对方向\rif(absD_t == 0) (now-\u0026gt;y)--;\rif(absD_t == 1) (now-\u0026gt;x)++;\rif(absD_t == 2) (now-\u0026gt;y)++;\rif(absD_t == 3) (now-\u0026gt;x)--;\r*absD = absD_t;\r// 执行\rgo_rel(relD);\rif(relD != 0)\tgo_rel(0);\r}\r 2、最短路径 2.1、建立等高表 等高表原理类似于等高线，在选定起点后，与其相连的点可以设置为该点高度值+1，利用广度优先算法遍历迷宫格，本迷宫的等高表数值为： 将其可视化后，它的形状类似一座山。 2.2、反向查找 既然等高表概念理解了，那么寻找最短路径就是从山顶扔下一颗球，由重力选择的路径即为最短路径。（在机器学习领域会有一个局部最优概念，这里不阐述）\n/** 关键函数集（4）：寻找最优路径\r* 回溯到起点后，开始根据广度优先算法寻找最优路径\r（1）首先根据之前记录的迷宫数组建立等高表\r（2）根据等高表反向记录最优路径\r（3）将路径记录到迷宫数组的高四位，这样可以复用之前的结构，将小车引导至终点\r**/\rbit bfs(uchar maze[SIZE][SIZE],xyTypeDef beg, xyTypeDef end){ // 广度优先算法\r//参数初始化\ruchar height[SIZE][SIZE] = {0xff}; // 初始化等高表\rxyTypeDef queue_xy[15]; // 初始化队列（经过测试，长度管够）\ruchar queue_len = 1; // 初始化队列长度标记量\rxyTypeDef queue_head; // 初始化队头\ruchar j, i; // 初始化迭代下标\rxyTypeDef temp; // 初始化一个临时变量\rxyTypeDef now; // 初始化当前位置\rinit_map(height);\rheight[beg.y][beg.x] = 0;\rqueue_xy[0].x = beg.x;\rqueue_xy[0].y = beg.y;\rwhile(queue_len\u0026gt;0){ // 当队列不为空\rqueue_head = queue_xy[0]; // 队首元素出队\rqueue_len--;\rfor(j=0; j\u0026lt;queue_len; j++){ // （由于用数组模拟队列，所以需要将所有元素手动前移）\rqueue_xy[j] = queue_xy[j+1];\r}\rfor(i=0; i\u0026lt;4; i++){ // 判断四个方向\rtemp = queue_head;\rif(i == 0) temp.y = queue_head.y-1;\rif(i == 1) temp.x = queue_head.x+1;\rif(i == 2) temp.y = queue_head.y+1;\rif(i == 3) temp.x = queue_head.x-1;\rif(temp.x\u0026gt;127||temp.y\u0026gt;127) continue;\rif(is_path(maze, queue_head, i) \u0026amp;\u0026amp; height[temp.y][temp.x]==255){ // 如果该坐标连通且第一次访问\rheight[temp.y][temp.x] = height[queue_head.y][queue_head.x] + 1; // 该坐标等高表+1\rqueue_xy[queue_len++] = temp; // 该坐标入队\r}\r}\r}\r// 等高表建立完毕，开始反向查找最优路径\rnow.x = end.x;\rnow.y = end.y;\rwhile(!(now.x==0\u0026amp;\u0026amp; now.y==0)){ // 如果还没到起点\rfor(i=0; i\u0026lt;4; i++){ // 扫描四个方向\rtemp = now;\rif(i == 0) temp.y = now.y-1;\rif(i == 1) temp.x = now.x+1;\rif(i == 2) temp.y = now.y+1;\rif(i == 3) temp.x = now.x-1;\rif(temp.x\u0026gt;127||temp.y\u0026gt;127) continue;\rif(is_path(maze, now, i) \u0026amp;\u0026amp; (height[temp.y][temp.x]==height[now.y][now.x]-1)){ // 如果该坐标连通且高度递减\rmaze[temp.y][temp.x] |= 0xf0; // 初始化迷宫数组该坐标的高四位\rmaze[temp.y][temp.x] \u0026amp;= ((i\u0026lt;\u0026lt;4)|0x0f); // 将这个方向写入高四位\rnow = temp; // 切换焦点\rbreak;\r}\r}\r}\rreturn 1;\r}\r 五、 整体架构 int main() {\ruchar maze[SIZE][SIZE] = {0xff}; // 定义迷宫数组，整个迷宫的数据均存储在这里\ruchar absD = 1;\t// 定义开始时的绝对方向\ruchar absD_t;\t// 定义目标方向（暂无）\rbit flag = 0;\t// 定义冲刺标记量\rxyTypeDef beg;\t// 定义起点坐标\rxyTypeDef now;\t// 定义当前坐标\rxyTypeDef end;\t// 定义终点坐标\rbeg.x = 0;\rbeg.y = 0;\rnow = beg;\rend.x = 7;\rend.y = 7;\rinit_map(maze);\rinit_tim2(5000);\r//ir_test();\rwhile(1){\rif(now.x==end.x\u0026amp;\u0026amp;now.y==end.y\u0026amp;\u0026amp;flag){ // 如果冲刺完毕，退出程序\rbeep = 0; delay(100); beep = 1;\rbreak;\r}\rif(now.x==beg.x\u0026amp;\u0026amp;now.y==beg.y\u0026amp;\u0026amp;absD==3){ // 如果回溯到起点，开始冲刺\rbeep = 0; delay(100); beep = 1;\rflag = bfs(maze, beg, end);\r}\rcollect_info(maze, now, absD);\t// （1）记录迷宫信息\rabsD_t = search_dir(maze, now, flag);\t// （2）确定下一个方向\rgo_to_next(\u0026amp;now, \u0026amp;absD, absD_t);\t// （3）执行该方向\rdelay(1000); // 延时，便于手扶\rview1(now.x); view2(now.y); // 刷新数码管显示当前坐标\r}\rwhile(1);\r}\r ","id":10,"section":"posts","summary":"一、简介 课设题目，这里简单总结一下思路。 二、功能分析 任意穿行 （寻找终点） 实现对步进电机的控制，包括正转反转及调速；对电机动作组进行封装，实现","tags":["C51"],"title":"【迷宫小车】基于51单片机的迷宫电脑鼠的设计","uri":"https://causehhc.github.io/2020/01/design-of-a-car-in-maze-based-on-c51/","year":"2020"},{"content":"","id":11,"section":"posts","summary":"","tags":[""],"title":"_template","uri":"https://causehhc.github.io/1/01/_template/","year":"0001"}],"tags":[{"title":"C51","uri":"https://causehhc.github.io/tags/c51/"},{"title":"Clion","uri":"https://causehhc.github.io/tags/clion/"},{"title":"FPGA","uri":"https://causehhc.github.io/tags/fpga/"},{"title":"JetBrains","uri":"https://causehhc.github.io/tags/jetbrains/"},{"title":"Keil","uri":"https://causehhc.github.io/tags/keil/"},{"title":"Python","uri":"https://causehhc.github.io/tags/python/"},{"title":"STM32","uri":"https://causehhc.github.io/tags/stm32/"},{"title":"Ubuntu","uri":"https://causehhc.github.io/tags/ubuntu/"}]}